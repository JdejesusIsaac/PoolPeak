"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importStar(require("axios"));
const ethers_1 = require("ethers");
const eventsource_1 = __importDefault(require("eventsource"));
const error_1 = require("./error");
const flashbots_1 = require("./flashbots");
const interfaces_1 = require("./api/interfaces");
const mungers_1 = require("./api/mungers");
const networks_1 = require("./api/networks");
const events_1 = require("./api/events");
const url_1 = require("url");
// when calling mev_simBundle on a {tx} specified bundle, how long to wait for target to appear onchain
const TIMEOUT_QUERY_TX_MS = 5 * 60 * 1000;
class MevShareClient {
    constructor(authSigner, network) {
        this.authSigner = authSigner;
        this.network = network;
        this.authSigner = authSigner;
        this.network = network;
    }
    /** Connect to Flashbots MEV-Share node on Mainnet. */
    static useEthereumMainnet(authSigner) {
        return new MevShareClient(authSigner, networks_1.SupportedNetworks.mainnet);
    }
    /** Connect to Flashbots MEV-Share node on Goerli. */
    static useEthereumGoerli(authSigner) {
        return new MevShareClient(authSigner, networks_1.SupportedNetworks.goerli);
    }
    /** Connect to supported networks by specifying a network with a `chainId`. */
    static fromNetwork(authSigner, { chainId }) {
        const chainNum = typeof chainId == "bigint" ? Number(chainId) : chainId;
        const network = networks_1.SupportedNetworks.getNetwork(chainNum);
        return new MevShareClient(authSigner, network);
    }
    /** Make an HTTP POST request to a JSON-RPC endpoint.
     * @param url - URL to send the request to.
     * @param payload - body & headers.
     * @returns Response data.
    */
    postRpc(url, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield axios_1.default.post(url, payload.body, {
                headers: payload.headers
            });
            const data = res.data;
            if (data.error) {
                throw new error_1.JsonRpcError(data.error);
            }
            return data.result;
        });
    }
    /** Make an HTTP GET request.
     * @param urlSuffix - URL to send the request to.
     */
    streamGet(urlSuffix) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = this.network.streamUrl;
            url = url.endsWith("/") ? url : url + "/";
            const res = yield axios_1.default.get(url + "api/v1/" + urlSuffix);
            return res.data;
        });
    }
    /**
     * Sends a POST request to the MEV-Share API and returns the data.
     * @param params - JSON-RPC params.
     * @param method - JSON-RPC method.
     * @returns Response data from the API request.
     */
    handleApiRequest(params, method) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return this.postRpc(this.network.apiUrl, yield (0, flashbots_1.getRpcRequest)(params, method, this.authSigner));
            }
            catch (e) {
                if (e instanceof axios_1.AxiosError) {
                    throw new error_1.NetworkFailure(e);
                }
                else {
                    throw e;
                }
            }
        });
    }
    /**
     * Registers the provided callback to be called when a new MEV-Share transaction is received.
     * @param event - The event received from the event stream.
     * @param callback - Async function to process pending tx.
     */
    onTransaction(event, callback) {
        if (!event.txs || (event.txs && event.txs.length === 1)) {
            callback(new events_1.PendingTransaction(event));
        }
    }
    /**
     * Registers the provided callback to be called when a new MEV-Share bundle is received.
     * @param event - The event received from the event stream.
     * @param callback - Async function to process pending tx.
     */
    onBundle(event, callback) {
        if (event.txs && event.txs.length > 1) {
            callback(new events_1.PendingBundle(event));
        }
    }
    /**
     * Starts listening to the MEV-Share event stream and registers the given callback to be invoked when the given event type is received.
     * @param eventType - The type of event to listen for. Options specified by StreamEvent enum.
     * @param callback - The function to call when a new event is received.
     * @returns Stream handler. Call `.close()` on it before terminating your program.
     */
    on(eventType, callback) {
        const events = new eventsource_1.default(this.network.streamUrl);
        const eventHandler = eventType === interfaces_1.StreamEventType.Transaction ? this.onTransaction :
            eventType === interfaces_1.StreamEventType.Bundle ? this.onBundle :
                () => { throw new error_1.UnimplementedStreamEvent(eventType); };
        events.onmessage = (event) => {
            try {
                eventHandler(JSON.parse(event.data), callback);
            }
            catch (e) {
                if (e instanceof axios_1.AxiosError) {
                    throw new error_1.NetworkFailure(e);
                }
                else {
                    throw e;
                }
            }
        };
        return events;
    }
    /** Sends a private transaction with MEV hints to the Flashbots MEV-Share node.
     * @param signedTx - Signed transaction to send.
     * @param options - Tx preferences; hints & block range.
     * @returns Transaction hash.
     */
    sendTransaction(signedTx, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = (0, mungers_1.mungePrivateTxParams)(signedTx, options);
            return yield this.handleApiRequest(params, "eth_sendPrivateTransaction");
        });
    }
    /** Sends a bundle to mev-share.
     * @param params - Parameters for the bundle.
     * @returns Array of bundle hashes.
     */
    sendBundle(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, interfaces_1.SendBundleResult)(yield this.handleApiRequest([(0, mungers_1.mungeBundleParams)(params)], "mev_sendBundle"));
        });
    }
    /**
     * Internal mev_simBundle call.
     *
     * Note: This may only be used on matched bundles.
     * Simulating unmatched bundles (i.e. bundles with a hash present) will throw an error.
     * @param params - Parameters for the bundle.
     * @param simOptions - Simulation options; override block header data for simulation.
     * @returns Simulation result.
     */
    simBundle(params, simOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, interfaces_1.SimBundleResult)(yield this.handleApiRequest([
                (0, mungers_1.mungeBundleParams)(params),
                simOptions ? (0, mungers_1.mungeSimBundleOptions)(simOptions) : {}
            ], "mev_simBundle"));
        });
    }
    /** Simulates a bundle specified by `params`.
     *
     * Bundles containing pending transactions (specified by `{hash}` instead of `{tx}` in `params.body`) may
     * only be simulated after those transactions have landed on chain. If the bundle contains
     * pending transactions, this method will wait for the transactions to land before simulating.
     * @param params - Parameters for the bundle.
     * @param simOptions - Simulation options; override block header data for simulation.
     * @returns Simulation result.
     */
    simulateBundle(params, simOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const firstTx = params.body[0];
            if ('hash' in firstTx) {
                console.log("Transaction hash: " + firstTx.hash + " must appear onchain before simulation is possible, waiting");
                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                    const provider = this.authSigner.provider;
                    if (provider == null) {
                        throw new Error("Need to wait for hash, but we don't have a provider. Attach one to signer wallet");
                    }
                    const waitForTx = () => __awaiter(this, void 0, void 0, function* () {
                        const tx = yield provider.getTransaction(firstTx.hash);
                        if (tx) {
                            provider.removeListener('block', waitForTx);
                            const signedTx = ethers_1.Transaction.from(tx).serialized;
                            console.log(`Found transaction hash: ${firstTx.hash} onchain at block number: ${tx.blockNumber}`);
                            if (!tx.blockNumber) {
                                return reject(new Error("Transaction hash: " + firstTx.hash + " does not have blockNumber"));
                            }
                            const simBlock = (simOptions === null || simOptions === void 0 ? void 0 : simOptions.parentBlock) || tx.blockNumber - 1;
                            const paramsWithSignedTx = Object.assign(Object.assign({}, params), { body: [
                                    {
                                        tx: signedTx, canRevert: false
                                    },
                                    ...params.body.slice(1),
                                ] });
                            resolve(this.simBundle(paramsWithSignedTx, Object.assign(Object.assign({}, simOptions), { parentBlock: simBlock })));
                            return true;
                        }
                        return false;
                    });
                    // manually call once in case tx is already landed
                    if (yield waitForTx()) {
                        return;
                    }
                    provider.on('block', waitForTx);
                    setTimeout(() => {
                        provider.removeListener('block', waitForTx);
                        console.error("Gave up waiting for " + firstTx.hash);
                        reject(new Error("Target transaction did not appear onchain before TIMEOUT_QUERY_TX_MS"));
                    }, TIMEOUT_QUERY_TX_MS);
                }));
            }
            return yield this.simBundle(params, simOptions);
        });
    }
    /** Gets information about query parameters for the event history endpoint. */
    getEventHistoryInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.streamGet("history/info");
        });
    }
    /** Gets past events that were broadcast via the SSE event stream. */
    getEventHistory(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const _params = params || {};
            const query = new url_1.URLSearchParams();
            for (const [key, value] of Object.entries(_params)) {
                query.set(key, value.toString());
            }
            const res = yield this.streamGet("history" + `?${query.toString()}`);
            return res.map((entry) => new interfaces_1.EventHistoryEntry(entry));
        });
    }
}
exports.default = MevShareClient;
//# sourceMappingURL=client.js.map