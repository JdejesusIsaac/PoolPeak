"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const async_mutex_1 = require("async-mutex");
const helpers_1 = require("./lib/helpers");
const sendTx_1 = require("./lib/sendTx");
const async_1 = require("./lib/async");
const NUM_TARGET_BLOCKS = 3;
/**
 * Generate a transaction to backrun a pending mev-share transaction and send it to mev-share.
 */
const sendTestBackrunBundle = (provider, pendingTx, mevshare, targetBlock) => __awaiter(void 0, void 0, void 0, function* () {
    // send bundle w/ (basefee + 100)gwei gas fee
    const { tx, wallet } = yield (0, sendTx_1.setupTxExample)(provider, BigInt(1e9) * BigInt(1e3), "im backrunniiiiing");
    const backrunTx = Object.assign(Object.assign({}, tx), { nonce: tx.nonce ? tx.nonce + 1 : undefined });
    const bundle = [
        { hash: pendingTx.hash },
        { tx: yield wallet.signTransaction(backrunTx), canRevert: false },
    ];
    console.log(`sending backrun bundles targeting next ${NUM_TARGET_BLOCKS} blocks...`);
    const bundleParams = {
        inclusion: {
            block: targetBlock,
            maxBlock: targetBlock + NUM_TARGET_BLOCKS,
        },
        body: bundle,
    };
    const backrunResult = yield mevshare.sendBundle(bundleParams);
    return {
        bundleParams,
        backrunResult,
    };
});
/** Async handler which backruns an mev-share tx with another basic example tx. */
const handleBackrun = (pendingTx, provider, mevshare, pendingMutex, pendingTxHashes) => __awaiter(void 0, void 0, void 0, function* () {
    console.log("pendingTxHashes", yield pendingTxHashes.get());
    if (!(yield pendingTxHashes.includes(pendingTx.hash))) {
        // ignore txs we didn't send. they break the bundle (nonce error) bc we're using one account to do everything
        return;
    }
    else {
        console.log("pending tx", pendingTx);
    }
    const targetBlock = (yield provider.getBlockNumber()) + 1;
    const { bundleParams, backrunResult, } = yield sendTestBackrunBundle(provider, pendingTx, mevshare, targetBlock);
    console.log("backrun result", backrunResult);
    // watch future blocks for backrun tx inclusion
    for (let i = 0; i < NUM_TARGET_BLOCKS; i++) {
        const currentBlock = targetBlock + i;
        if (!pendingMutex.isLocked()) {
            // mutex was released by another handler, so we can exit
            break;
        }
        console.log(`tx ${pendingTx.hash} waiting for block`, currentBlock);
        // stall until target block is available
        while ((yield provider.getBlockNumber()) < currentBlock) {
            yield new Promise(resolve => setTimeout(resolve, 6000));
        }
        // check for inclusion of backrun tx in target block
        const backrunTx = bundleParams.body[1].tx;
        if (backrunTx) {
            const checkTxHash = (0, ethers_1.keccak256)(backrunTx);
            const receipt = yield provider.getTransactionReceipt(checkTxHash);
            if ((receipt === null || receipt === void 0 ? void 0 : receipt.status) === 1) {
                console.log(`bundle included! (found tx ${receipt.hash})`);
                // simulate for funzies
                const simOptions = {
                    parentBlock: receipt.blockNumber - 1,
                };
                const simResult = yield mevshare.simulateBundle(bundleParams, simOptions);
                console.log(`simResult (simOptions=${JSON.stringify(simOptions, null, 2)})`, simResult);
                console.log(`profit: ${(0, ethers_1.formatEther)(simResult.profit)} ETH`);
                // release mutex so the main thread can exit
                pendingMutex.release();
                break;
            }
            else {
                console.warn(`backrun tx ${checkTxHash} not included in block ${currentBlock}`);
            }
        }
    }
    yield pendingTxHashes.filter(hash => hash !== pendingTx.hash);
    console.log("dropped target tx", pendingTx.hash);
});
/**
 * Sends a tx on every block and backruns it with a simple example tx.
 *
 * Continues until we land a backrun, then exits.
 */
const main = () => __awaiter(void 0, void 0, void 0, function* () {
    const provider = (0, helpers_1.getProvider)();
    const { mevshare } = yield (0, helpers_1.initExample)(provider);
    // used for tracking txs we sent. we only want to backrun txs we sent, 
    // since we're using one account and incrementing the nonce of the bundle's 2nd tx
    const pendingTxHashes = new async_1.AsyncArray();
    // used for blocking this thread until the handler is done processing
    const pendingMutex = new async_mutex_1.Mutex();
    // listen for txs
    const txHandler = mevshare.on("transaction", (pendingTx) => __awaiter(void 0, void 0, void 0, function* () {
        yield handleBackrun(pendingTx, provider, mevshare, pendingMutex, pendingTxHashes);
    }));
    console.log("listening for transactions...");
    yield pendingMutex.acquire();
    // send a tx that we can backrun on every block
    // tx will be backrun independently by the `handleBackrun` callback
    const blockHandler = yield provider.on("block", (blockNum) => __awaiter(void 0, void 0, void 0, function* () {
        if ((yield pendingTxHashes.length()) === 0) {
            const res = yield (0, sendTx_1.sendTx)(provider, { logs: true, contractAddress: true, calldata: true, functionSelector: true }, blockNum + NUM_TARGET_BLOCKS);
            console.log("sent tx", res);
            pendingTxHashes.push(res);
        }
    }));
    // will block until one of the handlers releases the mutex
    yield pendingMutex.acquire();
    pendingMutex.release();
    // stop listening for txs
    txHandler.close();
    yield blockHandler.removeAllListeners();
});
main().then(() => {
    process.exit(0);
});
//# sourceMappingURL=sendBackrunBundle.js.map