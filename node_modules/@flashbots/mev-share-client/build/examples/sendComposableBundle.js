"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const helpers_1 = require("./lib/helpers");
const env_1 = __importDefault(require("./lib/env"));
const NUM_TARGET_BLOCKS = 3;
/** Send a bundle that shares as much data as possible by setting the `privacy` param. */
const sendTestBundle = (provider, mevshare, wallet, targetBlock) => __awaiter(void 0, void 0, void 0, function* () {
    const feeData = yield provider.getFeeData();
    const tip = BigInt(1e9) * BigInt(2e7); // 0.02 eth
    const tx = {
        type: 2,
        chainId: provider._network.chainId,
        to: wallet.address,
        nonce: yield wallet.getNonce(),
        value: 0,
        gasLimit: 22000,
        data: (0, ethers_1.hexlify)((0, ethers_1.toUtf8Bytes)("im shariiiiiing")),
        maxFeePerGas: (0, ethers_1.toBigInt)(feeData.maxFeePerGas || 42) + tip,
        maxPriorityFeePerGas: (0, ethers_1.toBigInt)(feeData.maxPriorityFeePerGas || 2) + tip,
    };
    /*
        NOTE: only bundles comprised solely of signed transactions are supported at the moment.
        Bundles containing `hash` cannot set `privacy` settings.
    */
    const bundle = [
        { tx: yield wallet.signTransaction(tx), canRevert: false },
    ];
    console.log(`sending backrun bundles targeting next ${NUM_TARGET_BLOCKS} blocks...`);
    const bundleParams = {
        inclusion: {
            block: targetBlock,
            maxBlock: targetBlock + NUM_TARGET_BLOCKS,
        },
        body: bundle,
        privacy: {
            hints: {
                txHash: true,
                calldata: true,
                logs: true,
                functionSelector: true,
                contractAddress: true,
            },
            builders: ["flashbots"]
        }
    };
    const backrunResult = yield mevshare.sendBundle(bundleParams);
    return {
        bundleParams,
        backrunResult,
    };
});
const main = () => __awaiter(void 0, void 0, void 0, function* () {
    const provider = (0, helpers_1.getProvider)();
    const { mevshare } = yield (0, helpers_1.initExample)(provider);
    const targetBlock = (yield provider.getBlockNumber()) + 1;
    const wallet = new ethers_1.Wallet(env_1.default.senderKey, provider);
    const { bundleParams, backrunResult } = yield sendTestBundle(provider, mevshare, wallet, targetBlock);
    console.log("bundleParams", bundleParams);
    console.log("backrunResult", backrunResult);
});
main().then(() => {
    process.exit(0);
});
//# sourceMappingURL=sendComposableBundle.js.map